(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{358:function(v,e,_){"use strict";_.r(e);var o=_(40),d=Object(o.a)({},function(){var v=this,e=v.$createElement,_=v._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"vue"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue","aria-hidden":"true"}},[v._v("#")]),v._v(" Vue")]),v._v(" "),_("h3",{attrs:{id:"_1-对于mvvm的理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-对于mvvm的理解","aria-hidden":"true"}},[v._v("#")]),v._v(" 1 对于MVVM的理解")]),v._v(" "),_("blockquote",[_("p",[_("code",[v._v("MVVM")]),v._v(" 是 "),_("code",[v._v("Model-View-ViewModel")]),v._v(" 的缩写")])]),v._v(" "),_("ul",[_("li",[_("code",[v._v("Model")]),v._v(" 代表数据模型，也可以在"),_("code",[v._v("Model")]),v._v("中定义数据修改和操作的业务逻辑。")]),v._v(" "),_("li",[_("code",[v._v("View")]),v._v(" 代表"),_("code",[v._v("UI")]),v._v(" 组件，它负责将数据模型转化成"),_("code",[v._v("UI")]),v._v(" 展现出来。")]),v._v(" "),_("li",[_("code",[v._v("ViewModel")]),v._v(" 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 "),_("code",[v._v("Model")]),v._v("的对象，连接"),_("code",[v._v("Model")]),v._v("和"),_("code",[v._v("View")])])]),v._v(" "),_("blockquote",[_("ul",[_("li",[v._v("在"),_("code",[v._v("MVVM")]),v._v("架构下，"),_("code",[v._v("View")]),v._v("和 "),_("code",[v._v("Model")]),v._v(" 之间并没有直接的联系，而是通过"),_("code",[v._v("ViewModel")]),v._v("进行交互，"),_("code",[v._v("Model")]),v._v("和 "),_("code",[v._v("ViewModel")]),v._v(" 之间的交互是双向的， 因此"),_("code",[v._v("View")]),v._v(" 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到"),_("code",[v._v("View")]),v._v(" 上。")]),v._v(" "),_("li",[_("code",[v._v("ViewModel")]),v._v(" 通过双向数据绑定把 "),_("code",[v._v("View")]),v._v(" 层和 "),_("code",[v._v("Model")]),v._v("层连接了起来，而"),_("code",[v._v("View")]),v._v("和 "),_("code",[v._v("Model")]),v._v(" 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 "),_("code",[v._v("MVVM")]),v._v(" 来统一管理")])])]),v._v(" "),_("h3",{attrs:{id:"_2-请详细说下你对vue生命周期的理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-请详细说下你对vue生命周期的理解","aria-hidden":"true"}},[v._v("#")]),v._v(" 2 请详细说下你对vue生命周期的理解")]),v._v(" "),_("blockquote",[_("p",[v._v("答：总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后")])]),v._v(" "),_("ul",[_("li",[v._v("创建前/后： 在"),_("code",[v._v("beforeCreate")]),v._v("阶段，"),_("code",[v._v("vue")]),v._v("实例的挂载元素"),_("code",[v._v("el")]),v._v("和数据对象"),_("code",[v._v("data")]),v._v("都为"),_("code",[v._v("undefined")]),v._v("，还未初始化。在"),_("code",[v._v("created")]),v._v("阶段，"),_("code",[v._v("vue")]),v._v("实例的数据对象"),_("code",[v._v("data")]),v._v("有了，el还没有")]),v._v(" "),_("li",[v._v("载入前/后：在"),_("code",[v._v("beforeMount")]),v._v("阶段，"),_("code",[v._v("vue")]),v._v("实例的"),_("code",[v._v("$el")]),v._v("和"),_("code",[v._v("data")]),v._v("都初始化了，但还是挂载之前为虚拟的"),_("code",[v._v("dom")]),v._v("节点，"),_("code",[v._v("data.message")]),v._v("还未替换。在"),_("code",[v._v("mounted")]),v._v("阶段，"),_("code",[v._v("vue")]),v._v("实例挂载完成，"),_("code",[v._v("data.message")]),v._v("成功渲染。")]),v._v(" "),_("li",[v._v("更新前/后：当"),_("code",[v._v("data")]),v._v("变化时，会触发"),_("code",[v._v("beforeUpdate")]),v._v("和"),_("code",[v._v("updated")]),v._v("方法")]),v._v(" "),_("li",[v._v("销毁前/后：在执行"),_("code",[v._v("destroy")]),v._v("方法后，对"),_("code",[v._v("data")]),v._v("的改变不会再触发周期函数，说明此时"),_("code",[v._v("vue")]),v._v("实例已经解除了事件监听以及和"),_("code",[v._v("dom")]),v._v("的绑定，但是"),_("code",[v._v("dom")]),v._v("结构依然存在")])]),v._v(" "),_("p",[_("strong",[v._v("什么是vue生命周期？")])]),v._v(" "),_("ul",[_("li",[v._v("答： Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。")])]),v._v(" "),_("p",[_("strong",[v._v("vue生命周期的作用是什么？")])]),v._v(" "),_("ul",[_("li",[v._v("答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。")])]),v._v(" "),_("p",[_("strong",[v._v("vue生命周期总共有几个阶段？")])]),v._v(" "),_("ul",[_("li",[v._v("答：它可以总共分为"),_("code",[v._v("8")]),v._v("个阶段：创建前/后、载入前/后、更新前/后、销毁前/销毁后。")])]),v._v(" "),_("p",[_("strong",[v._v("第一次页面加载会触发哪几个钩子？")])]),v._v(" "),_("ul",[_("li",[v._v("答：会触发下面这几个"),_("code",[v._v("beforeCreate")]),v._v("、"),_("code",[v._v("created")]),v._v("、"),_("code",[v._v("beforeMount")]),v._v("、"),_("code",[v._v("mounted")]),v._v(" 。")])]),v._v(" "),_("p",[_("strong",[v._v("DOM 渲染在哪个周期中就已经完成？")])]),v._v(" "),_("ul",[_("li",[v._v("答："),_("code",[v._v("DOM")]),v._v(" 渲染在 "),_("code",[v._v("mounted")]),v._v(" 中就已经完成了")])]),v._v(" "),_("h3",{attrs:{id:"_3-vue实现数据双向绑定的原理：object-defineproperty"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-vue实现数据双向绑定的原理：object-defineproperty","aria-hidden":"true"}},[v._v("#")]),v._v(" 3 Vue实现数据双向绑定的原理：Object.defineProperty()")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("vue")]),v._v("实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 "),_("code",[v._v("Object.defineProperty()")]),v._v(" 来劫持各个属性的"),_("code",[v._v("setter")]),v._v("，"),_("code",[v._v("getter")]),v._v("，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 "),_("code",[v._v("Javascript")]),v._v(" 对象传给 Vue 实例来作为它的 "),_("code",[v._v("data")]),v._v(" 选项时，Vue 将遍历它的属性，用 "),_("code",[v._v("Object.defineProperty()")]),v._v(" 将它们转为 "),_("code",[v._v("getter/setter")]),v._v("。用户看不到 "),_("code",[v._v("getter/setter")]),v._v("，但是在内部它们让 "),_("code",[v._v("Vue")]),v._v("追踪依赖，在属性被访问和修改时通知变化。")]),v._v(" "),_("li",[v._v("vue的数据双向绑定 将"),_("code",[v._v("MVVM")]),v._v("作为数据绑定的入口，整合"),_("code",[v._v("Observer")]),v._v("，"),_("code",[v._v("Compile")]),v._v("和"),_("code",[v._v("Watcher")]),v._v("三者，通过"),_("code",[v._v("Observer")]),v._v("来监听自己的"),_("code",[v._v("model")]),v._v("的数据变化，通过"),_("code",[v._v("Compile")]),v._v("来解析编译模板指令（"),_("code",[v._v("vue")]),v._v("中是用来解析 "),_("code",[v._v("{{}}")]),v._v("），最终利用"),_("code",[v._v("watcher")]),v._v("搭起"),_("code",[v._v("observer")]),v._v("和"),_("code",[v._v("Compile")]),v._v("之间的通信桥梁，达到数据变化 —>视图更新；视图交互变化（"),_("code",[v._v("input")]),v._v("）—>数据"),_("code",[v._v("model")]),v._v("变更双向绑定效果。")])]),v._v(" "),_("h3",{attrs:{id:"_4-vue组件间的参数传递"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-vue组件间的参数传递","aria-hidden":"true"}},[v._v("#")]),v._v(" 4 Vue组件间的参数传递")]),v._v(" "),_("p",[_("strong",[v._v("父组件与子组件传值")])]),v._v(" "),_("blockquote",[_("p",[v._v("父组件传给子组件：子组件通过"),_("code",[v._v("props")]),v._v("方法接受数据；")])]),v._v(" "),_("ul",[_("li",[v._v("子组件传给父组件： "),_("code",[v._v("$emit")]),v._v(" 方法传递参数")])]),v._v(" "),_("p",[_("strong",[v._v("非父子组件间的数据传递，兄弟组件传值")])]),v._v(" "),_("blockquote",[_("p",[_("code",[v._v("eventBus")]),v._v("，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适（虽然也有不少人推荐直接用"),_("code",[v._v("VUEX")]),v._v("，具体来说看需求）")])]),v._v(" "),_("h3",{attrs:{id:"_5-vue的路由实现：hash模式-和-history模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-vue的路由实现：hash模式-和-history模式","aria-hidden":"true"}},[v._v("#")]),v._v(" 5 Vue的路由实现：hash模式 和 history模式")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("hash")]),v._v("模式：在浏览器中符号"),_("code",[v._v("“#”")]),v._v("，#以及#后面的字符称之为"),_("code",[v._v("hash")]),v._v("，用 "),_("code",[v._v("window.location.hash")]),v._v(" 读取。特点："),_("code",[v._v("hash")]),v._v("虽然在"),_("code",[v._v("URL")]),v._v("中，但不被包括在"),_("code",[v._v("HTTP")]),v._v("请求中；用来指导浏览器动作，对服务端安全无用，"),_("code",[v._v("hash")]),v._v("不会重加载页面。")]),v._v(" "),_("li",[_("code",[v._v("history")]),v._v("模式：h"),_("code",[v._v("istory")]),v._v("采用"),_("code",[v._v("HTML5")]),v._v("的新特性；且提供了两个新方法： "),_("code",[v._v("pushState()")]),v._v("， "),_("code",[v._v("replaceState()")]),v._v("可以对浏览器历史记录栈进行修改，以及"),_("code",[v._v("popState")]),v._v("事件的监听到状态变更")])]),v._v(" "),_("h3",{attrs:{id:"_5-vue路由的钩子函数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-vue路由的钩子函数","aria-hidden":"true"}},[v._v("#")]),v._v(" 5 vue路由的钩子函数")]),v._v(" "),_("blockquote",[_("p",[v._v("首页可以控制导航跳转，"),_("code",[v._v("beforeEach")]),v._v("，"),_("code",[v._v("afterEach")]),v._v("等，一般用于页面"),_("code",[v._v("title")]),v._v("的修改。一些需要登录才能调整页面的重定向功能。")])]),v._v(" "),_("ul",[_("li",[_("code",[v._v("beforeEach")]),v._v("主要有3个参数"),_("code",[v._v("to")]),v._v("，"),_("code",[v._v("from")]),v._v("，"),_("code",[v._v("next")]),v._v("。")]),v._v(" "),_("li",[_("code",[v._v("to")]),v._v("："),_("code",[v._v("route")]),v._v("即将进入的目标路由对象。")]),v._v(" "),_("li",[_("code",[v._v("from")]),v._v("："),_("code",[v._v("route")]),v._v("当前导航正要离开的路由。")]),v._v(" "),_("li",[_("code",[v._v("next")]),v._v("："),_("code",[v._v("function")]),v._v("一定要调用该方法"),_("code",[v._v("resolve")]),v._v("这个钩子。执行效果依赖n"),_("code",[v._v("ext")]),v._v("方法的调用参数。可以控制网页的跳转")])]),v._v(" "),_("h3",{attrs:{id:"_6-vuex是什么？怎么使用？哪种功能场景使用它？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-vuex是什么？怎么使用？哪种功能场景使用它？","aria-hidden":"true"}},[v._v("#")]),v._v(" 6 vuex是什么？怎么使用？哪种功能场景使用它？")]),v._v(" "),_("ul",[_("li",[v._v("只用来读取的状态集中放在"),_("code",[v._v("store")]),v._v("中； 改变状态的方式是提交"),_("code",[v._v("mutations")]),v._v("，这是个同步的事物； 异步逻辑应该封装在"),_("code",[v._v("action")]),v._v("中。")]),v._v(" "),_("li",[v._v("在"),_("code",[v._v("main.js")]),v._v("引入"),_("code",[v._v("store")]),v._v("，注入。新建了一个目录"),_("code",[v._v("store")]),v._v("，"),_("code",[v._v("… export")])]),v._v(" "),_("li",[_("strong",[v._v("场景有")]),v._v("：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/1480597-ad276e57b4a6e555.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"vuex"}})]),v._v(" "),_("ul",[_("li",[_("code",[v._v("state")]),v._v("："),_("code",[v._v("Vuex")]),v._v(" 使用单一状态树,即每个应用将仅仅包含一个"),_("code",[v._v("store")]),v._v(" 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。")]),v._v(" "),_("li",[_("code",[v._v("mutations")]),v._v("："),_("code",[v._v("mutations")]),v._v("定义的方法动态修改"),_("code",[v._v("Vuex")]),v._v(" 的 "),_("code",[v._v("store")]),v._v(" 中的状态或数据")]),v._v(" "),_("li",[_("code",[v._v("getters")]),v._v("：类似"),_("code",[v._v("vue")]),v._v("的计算属性，主要用来过滤一些数据。")]),v._v(" "),_("li",[_("code",[v._v("action")]),v._v("："),_("code",[v._v("actions")]),v._v("可以理解为通过将"),_("code",[v._v("mutations")]),v._v("里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。"),_("code",[v._v("view")]),v._v(" 层通过 "),_("code",[v._v("store.dispath")]),v._v(" 来分发 "),_("code",[v._v("action")])])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/1480597-0db932c9f1a54213.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"image.png"}})]),v._v(" "),_("blockquote",[_("p",[_("code",[v._v("modules")]),v._v("：项目特别复杂的时候，可以让每一个模块拥有自己的"),_("code",[v._v("state")]),v._v("、"),_("code",[v._v("mutation")]),v._v("、"),_("code",[v._v("action")]),v._v("、"),_("code",[v._v("getters")]),v._v("，使得结构非常清晰，方便管理")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/1480597-d8897c808f913010.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"image.png"}})]),v._v(" "),_("h3",{attrs:{id:"_7-v-if-和-v-show-区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-v-if-和-v-show-区别","aria-hidden":"true"}},[v._v("#")]),v._v(" 7 v-if 和 v-show 区别")]),v._v(" "),_("ul",[_("li",[v._v("答："),_("code",[v._v("v-if")]),v._v("按照条件是否渲染，"),_("code",[v._v("v-show")]),v._v("是"),_("code",[v._v("display")]),v._v("的"),_("code",[v._v("block")]),v._v("或"),_("code",[v._v("none")]),v._v("；")])]),v._v(" "),_("h3",{attrs:{id:"_8-route和-router的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-route和-router的区别","aria-hidden":"true"}},[v._v("#")]),v._v(" 8 "),_("code",[v._v("$route")]),v._v("和"),_("code",[v._v("$router")]),v._v("的区别")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("$route")]),v._v("是“路由信息对象”，包括"),_("code",[v._v("path")]),v._v("，"),_("code",[v._v("params")]),v._v("，"),_("code",[v._v("hash")]),v._v("，"),_("code",[v._v("query")]),v._v("，"),_("code",[v._v("fullPath")]),v._v("，"),_("code",[v._v("matched")]),v._v("，"),_("code",[v._v("name")]),v._v("等路由信息参数。")]),v._v(" "),_("li",[v._v("而"),_("code",[v._v("$router")]),v._v("是“路由实例”对象包括了路由的跳转方法，钩子函数等")])]),v._v(" "),_("h3",{attrs:{id:"_9-如何让css只在当前组件中起作用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-如何让css只在当前组件中起作用","aria-hidden":"true"}},[v._v("#")]),v._v(" 9 如何让CSS只在当前组件中起作用?")]),v._v(" "),_("blockquote",[_("p",[v._v("将当前组件的"),_("code",[v._v("<style>")]),v._v("修改为"),_("code",[v._v("<style scoped>")])])]),v._v(" "),_("h3",{attrs:{id:"_10-keep-alive-keep-alive-的作用是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10-keep-alive-keep-alive-的作用是什么","aria-hidden":"true"}},[v._v("#")]),v._v(" 10 "),_("code",[v._v("<keep-alive></keep-alive>")]),v._v("的作用是什么?")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("<keep-alive></keep-alive>")]),v._v(" 包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染")])]),v._v(" "),_("blockquote",[_("p",[v._v("比如有一个列表和一个详情，那么用户就会经常执行打开详情=>返回列表=>打开详情…这样的话列表和详情都是一个频率很高的页面，那么就可以对列表组件使用"),_("code",[v._v("<keep-alive></keep-alive>")]),v._v("进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染")])]),v._v(" "),_("h3",{attrs:{id:"_11-指令v-el的作用是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_11-指令v-el的作用是什么","aria-hidden":"true"}},[v._v("#")]),v._v(" 11 指令v-el的作用是什么?")]),v._v(" "),_("blockquote",[_("p",[v._v("提供一个在页面上已存在的 "),_("code",[v._v("DOM")]),v._v("元素作为 "),_("code",[v._v("Vue")]),v._v("实例的挂载目标.可以是 CSS 选择器，也可以是一个 "),_("code",[v._v("HTMLElement")]),v._v(" 实例,")])]),v._v(" "),_("h3",{attrs:{id:"_12-在vue中使用插件的步骤"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12-在vue中使用插件的步骤","aria-hidden":"true"}},[v._v("#")]),v._v(" 12 在Vue中使用插件的步骤")]),v._v(" "),_("ul",[_("li",[v._v("采用"),_("code",[v._v("ES6")]),v._v("的"),_("code",[v._v("import ... from ...")]),v._v("语法或"),_("code",[v._v("CommonJS")]),v._v("的"),_("code",[v._v("require()")]),v._v("方法引入插件")]),v._v(" "),_("li",[v._v("使用全局方法"),_("code",[v._v("Vue.use( plugin )")]),v._v("使用插件,可以传入一个选项对象"),_("code",[v._v("Vue.use(MyPlugin, { someOption: true })")])])]),v._v(" "),_("h3",{attrs:{id:"_13-请列举出3个vue中常用的生命周期钩子函数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_13-请列举出3个vue中常用的生命周期钩子函数","aria-hidden":"true"}},[v._v("#")]),v._v(" 13 请列举出3个Vue中常用的生命周期钩子函数?")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("created")]),v._v(": 实例已经创建完成之后调用,在这一步,实例已经完成数据观测, 属性和方法的运算, "),_("code",[v._v("watch/event")]),v._v("事件回调. 然而, 挂载阶段还没有开始, "),_("code",[v._v("$el")]),v._v("属性目前还不可见")]),v._v(" "),_("li",[_("code",[v._v("mounted")]),v._v(": "),_("code",[v._v("el")]),v._v("被新创建的 "),_("code",[v._v("vm.$el")]),v._v(" 替换，并挂载到实例上去之后调用该钩子。如果 "),_("code",[v._v("root")]),v._v(" 实例挂载了一个文档内元素，当 "),_("code",[v._v("mounted")]),v._v("被调用时 "),_("code",[v._v("vm.$el")]),v._v(" 也在文档内。")]),v._v(" "),_("li",[_("code",[v._v("activated")]),v._v(": "),_("code",[v._v("keep-alive")]),v._v("组件激活时调用")])]),v._v(" "),_("h3",{attrs:{id:"_14-vue-cli-工程技术集合介绍"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_14-vue-cli-工程技术集合介绍","aria-hidden":"true"}},[v._v("#")]),v._v(" 14 \bvue-cli 工程技术集合介绍")]),v._v(" "),_("p",[_("strong",[v._v("问题一：构建的 vue-cli 工程都到了哪些技术，它们的作用分别是什么？")])]),v._v(" "),_("ul",[_("li",[_("code",[v._v("vue.js")]),v._v("："),_("code",[v._v("vue-cli")]),v._v("工程的核心，主要特点是 双向数据绑定 和 组件系统。")]),v._v(" "),_("li",[_("code",[v._v("vue-router")]),v._v("："),_("code",[v._v("vue")]),v._v("官方推荐使用的路由框架。")]),v._v(" "),_("li",[_("code",[v._v("vuex")]),v._v("：专为 "),_("code",[v._v("Vue.js")]),v._v(" 应用项目开发的状态管理器，主要用于维护"),_("code",[v._v("vue")]),v._v("组件间共用的一些 变量 和 方法。")]),v._v(" "),_("li",[_("code",[v._v("axios")]),v._v("（ 或者 "),_("code",[v._v("fetch")]),v._v(" 、"),_("code",[v._v("ajax")]),v._v(" ）：用于发起 "),_("code",[v._v("GET")]),v._v(" 、或 "),_("code",[v._v("POST")]),v._v(" 等 "),_("code",[v._v("http")]),v._v("请求，基于 "),_("code",[v._v("Promise")]),v._v(" 设计。")]),v._v(" "),_("li",[_("code",[v._v("vuex")]),v._v("等：一个专为"),_("code",[v._v("vue")]),v._v("设计的移动端"),_("code",[v._v("UI")]),v._v("组件库。")]),v._v(" "),_("li",[v._v("创建一个"),_("code",[v._v("emit.js")]),v._v("文件，用于"),_("code",[v._v("vue")]),v._v("事件机制的管理。")]),v._v(" "),_("li",[_("code",[v._v("webpack")]),v._v("：模块加载和"),_("code",[v._v("vue-cli")]),v._v("工程打包器。")])]),v._v(" "),_("p",[_("strong",[v._v("问题二：vue-cli 工程常用的 npm 命令有哪些？")])]),v._v(" "),_("ul",[_("li",[v._v("下载 "),_("code",[v._v("node_modules")]),v._v(" 资源包的命令：")])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("npm install\n")])])]),_("ul",[_("li",[v._v("启动 "),_("code",[v._v("vue-cli")]),v._v(" 开发环境的 npm命令：")])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("npm run dev\n")])])]),_("ul",[_("li",[_("code",[v._v("vue-cli")]),v._v(" 生成 生产环境部署资源 的 "),_("code",[v._v("npm")]),v._v("命令：")])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("npm run build\n")])])]),_("ul",[_("li",[v._v("用于查看 "),_("code",[v._v("vue-cli")]),v._v(" 生产环境部署资源文件大小的 "),_("code",[v._v("npm")]),v._v("命令：")])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("npm run build --report\n")])])]),_("blockquote",[_("p",[v._v("在浏览器上自动弹出一个 展示 "),_("code",[v._v("vue-cli")]),v._v(" 工程打包后 "),_("code",[v._v("app.js")]),v._v("、"),_("code",[v._v("manifest.js")]),v._v("、"),_("code",[v._v("vendor.js")]),v._v(" 文件里面所包含代码的页面。可以具此优化 "),_("code",[v._v("vue-cli")]),v._v(" 生产环境部署的静态资源，提升 页面 的加载速度")])]),v._v(" "),_("h3",{attrs:{id:"_15-nexttick"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_15-nexttick","aria-hidden":"true"}},[v._v("#")]),v._v(" 15 NextTick")]),v._v(" "),_("blockquote",[_("p",[_("code",[v._v("nextTick")]),v._v("可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 "),_("code",[v._v("DOM")])])]),v._v(" "),_("h3",{attrs:{id:"_16-vue的优点是什么？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_16-vue的优点是什么？","aria-hidden":"true"}},[v._v("#")]),v._v(" 16 vue的优点是什么？")]),v._v(" "),_("ul",[_("li",[v._v("低耦合。视图（"),_("code",[v._v("View")]),v._v("）可以独立于"),_("code",[v._v("Model")]),v._v("变化和修改，一个"),_("code",[v._v("ViewModel")]),v._v("可以绑定到不同的"),_("code",[v._v('"View"')]),v._v("上，当View变化的时候Model可以不变，当"),_("code",[v._v("Model")]),v._v("变化的时候"),_("code",[v._v("View")]),v._v("也可以不变")]),v._v(" "),_("li",[v._v("可重用性。你可以把一些视图逻辑放在一个"),_("code",[v._v("ViewModel")]),v._v("里面，让很多"),_("code",[v._v("view")]),v._v("重用这段视图逻辑")]),v._v(" "),_("li",[v._v("可测试。界面素来是比较难于测试的，而现在测试可以针对"),_("code",[v._v("ViewModel")]),v._v("来写")])]),v._v(" "),_("h3",{attrs:{id:"_17-路由之间跳转？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_17-路由之间跳转？","aria-hidden":"true"}},[v._v("#")]),v._v(" 17 路由之间跳转？")]),v._v(" "),_("p",[_("strong",[v._v("声明式（标签跳转）")])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v('<router-link :to="index">\n')])])]),_("p",[_("strong",[v._v("编程式（ js跳转）")])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("router.push('index')\n")])])]),_("h3",{attrs:{id:"_18-实现-vue-ssr"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_18-实现-vue-ssr","aria-hidden":"true"}},[v._v("#")]),v._v(" 18 实现 Vue SSR")]),v._v(" "),_("p",[_("img",{attrs:{src:"http://7xq6al.com1.z0.glb.clouddn.com/vue-ssr.jpg",alt:""}})]),v._v(" "),_("p",[_("strong",[v._v("其基本实现原理")])]),v._v(" "),_("ul",[_("li",[_("code",[v._v("app.js")]),v._v(" 作为客户端与服务端的公用入口，导出 "),_("code",[v._v("Vue")]),v._v(" 根实例，供客户端 "),_("code",[v._v("entry")]),v._v(" 与服务端 "),_("code",[v._v("entry")]),v._v(" 使用。客户端 "),_("code",[v._v("entry")]),v._v(" 主要作用挂载到 "),_("code",[v._v("DOM")]),v._v(" 上，服务端 "),_("code",[v._v("entry")]),v._v(" 除了创建和返回实例，还进行路由匹配与数据预获取。")]),v._v(" "),_("li",[_("code",[v._v("webpack")]),v._v(" 为客服端打包一个 "),_("code",[v._v("Client Bundle")]),v._v(" ，为服务端打包一个 "),_("code",[v._v("Server Bundle")]),v._v(" 。")]),v._v(" "),_("li",[v._v("服务器接收请求时，会根据 "),_("code",[v._v("url")]),v._v("，加载相应组件，获取和解析异步数据，创建一个读取 "),_("code",[v._v("Server Bundle")]),v._v(" 的 "),_("code",[v._v("BundleRenderer")]),v._v("，然后生成 "),_("code",[v._v("html")]),v._v(" 发送给客户端。")]),v._v(" "),_("li",[v._v("客户端混合，客户端收到从服务端传来的 "),_("code",[v._v("DOM")]),v._v(" 与自己的生成的 DOM 进行对比，把不相同的 "),_("code",[v._v("DOM")]),v._v(" 激活，使其可以能够响应后续变化，这个过程称为客户端激活 。为确保混合成功，客户端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 "),_("code",[v._v("stroe")]),v._v(" 里，这样，在客户端挂载到 "),_("code",[v._v("DOM")]),v._v(" 之前，可以直接从 "),_("code",[v._v("store")]),v._v("里取数据。首屏的动态数据通过 "),_("code",[v._v("window.__INITIAL_STATE__")]),v._v("发送到客户端")])]),v._v(" "),_("blockquote",[_("p",[_("code",[v._v("Vue SSR")]),v._v(" 的实现，主要就是把 "),_("code",[v._v("Vue")]),v._v(" 的组件输出成一个完整 "),_("code",[v._v("HTML")]),v._v(", "),_("code",[v._v("vue-server-renderer")]),v._v(" 就是干这事的")])]),v._v(" "),_("ul",[_("li",[_("code",[v._v("Vue SSR")]),v._v("需要做的事多点（输出完整 HTML），除了"),_("code",[v._v("complier -> vnode")]),v._v("，还需如数据获取填充至 "),_("code",[v._v("HTML")]),v._v("、客户端混合（"),_("code",[v._v("hydration")]),v._v("）、缓存等等。\n相比于其他模板引擎（"),_("code",[v._v("ejs")]),v._v(", "),_("code",[v._v("jade")]),v._v(" 等），最终要实现的目的是一样的，性能上可能要差点")])]),v._v(" "),_("h3",{attrs:{id:"_19-vue-组件-data-为什么必须是函数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_19-vue-组件-data-为什么必须是函数","aria-hidden":"true"}},[v._v("#")]),v._v(" 19 Vue 组件 data 为什么必须是函数")]),v._v(" "),_("ul",[_("li",[v._v("每个组件都是 "),_("code",[v._v("Vue")]),v._v(" 的实例。")]),v._v(" "),_("li",[v._v("组件共享 "),_("code",[v._v("data")]),v._v(" 属性，当 "),_("code",[v._v("data")]),v._v(" 的值是同一个引用类型的值时，改变其中一个会影响其他")])]),v._v(" "),_("h3",{attrs:{id:"_20-vue-computed-实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_20-vue-computed-实现","aria-hidden":"true"}},[v._v("#")]),v._v(" 20 Vue computed 实现")]),v._v(" "),_("ul",[_("li",[v._v("建立与其他属性（如："),_("code",[v._v("data")]),v._v("、 "),_("code",[v._v("Store")]),v._v("）的联系；")]),v._v(" "),_("li",[v._v("属性改变后，通知计算属性重新计算")])]),v._v(" "),_("blockquote",[_("p",[v._v("实现时，主要如下")])]),v._v(" "),_("ul",[_("li",[v._v("初始化 "),_("code",[v._v("data")]),v._v("， 使用 "),_("code",[v._v("Object.defineProperty")]),v._v(" 把这些属性全部转为 "),_("code",[v._v("getter/setter")]),v._v("。")]),v._v(" "),_("li",[v._v("初始化 "),_("code",[v._v("computed")]),v._v(", 遍历 "),_("code",[v._v("computed")]),v._v(" 里的每个属性，每个 "),_("code",[v._v("computed")]),v._v(" 属性都是一个 "),_("code",[v._v("watch")]),v._v(" 实例。每个属性提供的函数作为属性的 "),_("code",[v._v("getter")]),v._v("，使用 "),_("code",[v._v("Object.defineProperty")]),v._v(" 转化。")]),v._v(" "),_("li",[_("code",[v._v("Object.defineProperty getter")]),v._v(" 依赖收集。用于依赖发生变化时，触发属性重新计算。")]),v._v(" "),_("li",[v._v("若出现当前 "),_("code",[v._v("computed")]),v._v(" 计算属性嵌套其他 "),_("code",[v._v("computed")]),v._v(" 计算属性时，先进行其他的依赖收集")])]),v._v(" "),_("h3",{attrs:{id:"_21-vue-complier-实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_21-vue-complier-实现","aria-hidden":"true"}},[v._v("#")]),v._v(" 21 Vue complier 实现")]),v._v(" "),_("ul",[_("li",[v._v("模板解析这种事，本质是将数据转化为一段 "),_("code",[v._v("html")]),v._v(" ，最开始出现在后端，经过各种处理吐给前端。随着各种 "),_("code",[v._v("mv*")]),v._v(" 的兴起，模板解析交由前端处理。")]),v._v(" "),_("li",[v._v("总的来说，"),_("code",[v._v("Vue complier")]),v._v(" 是将 "),_("code",[v._v("template")]),v._v(" 转化成一个 "),_("code",[v._v("render")]),v._v(" 字符串。")])]),v._v(" "),_("blockquote",[_("p",[v._v("可以简单理解成以下步骤：")])]),v._v(" "),_("ul",[_("li",[_("code",[v._v("parse")]),v._v(" 过程，将 "),_("code",[v._v("template")]),v._v(" 利用正则转化成"),_("code",[v._v("AST")]),v._v(" 抽象语法树。")]),v._v(" "),_("li",[_("code",[v._v("optimize")]),v._v(" 过程，标记静态节点，后 "),_("code",[v._v("diff")]),v._v(" 过程跳过静态节点，提升性能。")]),v._v(" "),_("li",[_("code",[v._v("generate")]),v._v(" 过程，生成 "),_("code",[v._v("render")]),v._v(" 字符串")])]),v._v(" "),_("h3",{attrs:{id:"_22-怎么快速定位哪个组件出现性能问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_22-怎么快速定位哪个组件出现性能问题","aria-hidden":"true"}},[v._v("#")]),v._v(" 22 怎么快速定位哪个组件出现性能问题")]),v._v(" "),_("blockquote",[_("p",[v._v("用 "),_("code",[v._v("timeline")]),v._v(" 工具。 大意是通过 "),_("code",[v._v("timeline")]),v._v(" 来查看每个函数的调用时常，定位出哪个函数的问题，从而能判断哪个组件出了问题")])])])},[],!1,null,null,null);e.default=d.exports}}]);